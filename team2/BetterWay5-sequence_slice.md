Better Way 5 시퀀스를 슬라이스 하는 방법을 알자
======================================
* Slicing(슬라이싱)이란? Sequnce Type에서 데이터를 부분적으로 꺼내서 사용하는 것.

***
# 기본
* 파이썬은 시퀀스를 슬라이스(slice: 자르기)해서 조각으로 만드는 문법을 제공
** 슬라이스하면 최소한의 노력으로 시퀀스 아이템의 부분집합(subset)에 접근 가능
** 가장 간단한 슬라이싱 대상 : 내장 타입인 list, str, bytes
** 특별한 메서드를 구현하는 파이썬의 클래스에도 슬라이싱을 적용 가능 : __getitem__ , __setitem__

* 슬라이싱 문법
** 기본 형태는 somelist[start:end]
*** start 인덱스는 포함, end 인덱스는 제외

```python
a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
print('First four:', a[:4])
print('Last four:', a[-4:])
print('Diddle two:', a[3:-3])
  
>>>
Fisrt four: ['a', 'b', 'c', 'd']
Last four: ['e', 'f', 'g', 'h']
Middle two: ['d', 'e']
```

 리스트의 처음부터 슬라이스 할 때는 보기 편하게 인덱스 0을 생략
* ```assert a[:5] == a[0:5]```
리스트의 끝까지 슬라이스할 때도 마지막 인덱스는 넣지 않아도 되므로 생략
* ```assert a[5:] == a[5:len(a)]```

 슬라이싱은 start와 end 인덱스가 리스트의 경계를 벗어나도 적절하게 처리
* ```first_twenty_items = a[:20]```
* ```last_tenty_items = a[-20:]```

* 슬라이스코드 예제
```python
  a[:]    # ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
  a[:5]   # ['a', 'b', 'c', 'd', 'e']
  a[:-1]  # ['a', 'b', 'c', 'd', 'e', 'f', 'g']
  a[4:]   #                     ['e', 'f', 'g', 'h']
  a[-3:]  #                          ['f', 'g', 'h']
  a[2:5]  #           ['c', 'd', 'e']
  a[2:-1] #           ['c', 'd', 'e', 'f', 'g']
  a[-3:-1]#                          ['f', 'g']
```
  
***

# 예외나 뜻밖의 결과
```python
  a[20]
  >>>
  IndexError: list index our of range
```
* 리스트의 인덱스를 음수 변수로 지정하면 슬라이싱으로 뜻밖의 결과를 얻는 몇가지 상황 중 하나 발생
  *   somelist[- n:]
    * somelist[- 3:]처럼 n이 1보다 클 때는 제대로 동작
    * somelist[- 0:]처럼 n이 1보다 작을 때는 원본 리스트의 복사본을 만듬

# 그 외
* 슬라이싱의 결과는 완전히 새로운 리스트
** 원본 리스트에 들어있는 객체에 대한 참조는 유지
** 하지만 슬라이스한 결과를 수정해도 원본 리스트에 아무런 영향을 미치지 않음
```python
  b = a[4:]
  print('Before:  ', b)
  b[1] = 99
  print('After:   ', b)
  print('No change:', a)
  
  >>>
  Before:   ['e', 'f', 'g', 'h']
  After:    ['e', 99, 'g', 'h']
  No change:['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
```
* 할당에 사용하면 슬라이스는 원본 리스트에서 지정한 범위를 대체
  * a, b = c[:2] 같은 튜플 할당과 달리 슬라이스 할당의 길이는 달라도 됨
  * 할당받은 슬라이스의 앞뒤 값은 유지
  * 리스트는 새로 들어온 값에 맞춰 늘어나거나 줄어 듬

```python
  print('Before ', a)
  a[2:7] = [99, 22, 14]
  print('After ', a)
  
  >>>
  Before ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
  After  ['a', 'b', 99, 22, 14, 'h']
```

* 시작과 끝 인덱스를 모두 생략하고 슬라이스하면 원본리스트의 복사본을 얻음
```python
  b = a[:]
  assert b == a and b is not a
```
* 슬라이스에 시작과 끝 인덱스를 지정하지 않고 할당하면(새 리스트를 할당하지 않고) 슬라이스의 전체내용을 참조 대상의 복사본으로 대체
```python
  b = a
  print('Before', a)
  a[:] = [101, 102, 103]
  assert a is b           # 여전히 같은 리스트 객체
  print('After', a)       # 이제 다른 내용을 담음
  
  >>>
  Before ['a', 'b', 99, 22, 14, 'h']
  After  [101, 102, 103]
```
***

# 핵심정리
* 너무 장확하게 하지 말 것. start 인덱스 0 혹은 end 인덱스 시퀀스 길이 설정 하지 말 것.
* 슬라이싱은 범위를 벗어난 start나 end 인덱스를 허용, a[:20]이나 a[-20]처럼 시퀀스의 앞쪽이나 뒤쪽 경계에 놓인 슬라이스를 표현하기 쉬움
* list 슬라이스에 할당하면 원본시퀀스에 지정한 범위를 참조 대상의 내용을 대체함(길이가 달라도 동작)
